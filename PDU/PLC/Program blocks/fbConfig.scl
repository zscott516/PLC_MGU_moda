FUNCTION_BLOCK "fbConfig"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 0.1
   VAR_INPUT RETAIN
      bInSimulation { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool := false;   // If true, skips IO reconfig steps
   END_VAR

   VAR RETAIN
      Controls : Struct
         iSetNumRooms : Int := 1;
         arrSetNumRacksPerRoom : Array[1.."MAX_ROOMS"] of Int := [4];
         bSetConfig { ExternalVisible := 'False'} : Bool := true;
      END_STRUCT;
   END_VAR
   VAR 
      Status { ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         bDone { ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
         bBusy { ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
         bError { ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
         ErrorMsg { ExternalVisible := 'False'; ExternalWritable := 'False'} : String;
      END_STRUCT;
      iNumRooms { ExternalVisible := 'False'; ExternalWritable := 'False'} : Int := 1;
      iStep { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;
      iNextStep { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;
      R_TRIG_SetConfig {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : R_TRIG;
      ReconfigIOSystem {InstructionName := 'ReconfigIOSystem'; LibVersion := '1.2'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : ReconfigIOSystem;
   END_VAR

   VAR_TEMP 
      iRoomIndex : Int;
      iRackIndex : Int;
      i : Int;
      bSettingsValid : Bool;
      strErrorCode : String;
      retVal : Word;
   END_VAR

   VAR CONSTANT 
      eStep_ValidateConfig : Int;
      eStep_SetUp : Int := 1;
      eStep_Deactivate : Int := 2;
      eStep_WaitForDeactivate : Int := 3;
      eStep_Reconfig : Int := 4;
      eStep_WaitForReconfig : Int := 5;
      eStep_Restart : Int := 6;
      eStep_Done : Int := 7;
      eStep_Error : Int := 8;
   END_VAR


BEGIN
	// Enables IO racks based on the number of configured rooms and racks.
	// The intention is for everything to be configurable via the OPC UA interface and nothing
	// needs to be changed in TIA Portal, so that all deployments regardless of size can use the same codebase.
	
	// Global constants for reference:
	(*
	"MAX_ROOMS"
	"MAX_RACKS_PER_ROOM"
	"MAX_VFDS"
	
	"NUM_AI_ROOM"
	"NUM_AI_RACK"
	"MAX_AI_TOTAL"
	
	"NUM_DQ_ROOM"
	"NUM_DQ_RACK"
	"MAX_DQ_TOTAL"
	*)
	
	REGION 0: Validate config, set num racks and rooms
	    
	    // wait for start command
	    #R_TRIG_SetConfig(CLK:= #Controls.bSetConfig);
	    
	    // also trigger on PLC startup
	    IF "FirstScan" OR #iStep = #eStep_ValidateConfig OR
	        (#R_TRIG_SetConfig.Q AND (#iStep = #eStep_Done OR #iStep = #eStep_Error) ) THEN
	        
	        REGION Check error conditions            
	            // make sure specified number of rooms and racks is valid
	            #bSettingsValid := TRUE;
	            #Status.ErrorMsg := '';
	            (*
	            IF #Controls.iSetNumRooms > "MAX_ROOMS" THEN
	                #bSettingsValid := FALSE;
	                #Status.ErrorMsg := CONCAT(IN1 := #Status.ErrorMsg, IN2 := ' NumRooms > MAX ');
	            END_IF;
	            
	            FOR #i := 1 TO UINT_TO_INT("MAX_ROOMS") DO
	                IF #Controls.arrSetNumRacksPerRoom[#i] > "MAX_RACKS_PER_ROOM" THEN
	                    #bSettingsValid := FALSE;
	                    #Status.ErrorMsg := CONCAT(IN1 := #Status.ErrorMsg, IN2 := ' NumRacks > MAX ');
	                    EXIT;
	                END_IF;
	            END_FOR;
	            
	            IF "MAX_AI_PER_ROOM" <> ("NUM_AI_ROOM" + "NUM_AI_RACK" * "MAX_RACKS_PER_ROOM" + "EXTRA_AI_PER_ROOM") OR ( "MAX_AI_PER_ROOM" MOD 4 <> 0) THEN
	                #bSettingsValid := FALSE;
	                #Status.ErrorMsg := CONCAT(IN1 := #Status.ErrorMsg, IN2 := ' MAX_AI_PER_ROOM incorrect ');
	            END_IF;
	            
	            IF "MAX_DQ_PER_ROOM" <> ("NUM_DQ_ROOM" + "NUM_DQ_RACK" * "MAX_RACKS_PER_ROOM" + "EXTRA_DQ_PER_ROOM") OR ( "MAX_DQ_PER_ROOM" MOD 8 <> 0) THEN
	                #bSettingsValid := FALSE;
	                #Status.ErrorMsg := CONCAT(IN1 := #Status.ErrorMsg, IN2 := ' MAX_DQ_PER_ROOM incorrect ');
	            END_IF;
	            *)
	            
	        END_REGION
	        
	        IF #bSettingsValid THEN
	            // set number of rooms
	            #iNumRooms := #Controls.iSetNumRooms;
	            
	            FOR #iRoomIndex := 1 TO #iNumRooms DO
	                // set number of racks in each room
	                "dbMain".Room[#iRoomIndex].Config.iNumRacks := #Controls.arrSetNumRacksPerRoom[#iRoomIndex];
	            END_FOR;
	            
	            //#iNextStep := #eStep_SetUp;
	            #iNextStep := #eStep_Done;
	        ELSE
	            #iNextStep := #eStep_Error;
	            
	        END_IF;
	        
	    END_IF;
	    
	END_REGION
	
	
	
	(*
	REGION 1: Set up params
	    
	    IF #iStep = #eStep_SetUp THEN
	       
	        IF #bInSimulation THEN
	            #iNextStep := #eStep_Done;
	        ELSE
	            #iNextStep := #eStep_Deactivate;
	        END_IF;
	        
	    END_IF;
	END_REGION
	*)
	
	(*
	REGION Call ReconfigIOSystem FB
	
	    CASE #iStep OF
	        #eStep_Deactivate:
	            #ReconfigIOSystem.REQ := TRUE;
	            #ReconfigIOSystem.MODE := 1;
	            IF #ReconfigIOSystem.DONE THEN
	                #iNextStep := #eStep_WaitForDeactivate;
	            END_IF;
	            
	        #eStep_WaitForDeactivate:
	            #ReconfigIOSystem.REQ := FALSE;
	            #iNextStep := #eStep_Reconfig;
	            
	        #eStep_Reconfig:
	            #ReconfigIOSystem.REQ := TRUE;
	            #ReconfigIOSystem.MODE := 2;
	            IF #ReconfigIOSystem.DONE THEN
	                #iNextStep := #eStep_WaitForReconfig;
	            END_IF;
	            
	        #eStep_WaitForReconfig:
	            #ReconfigIOSystem.REQ := FALSE;
	            #iNextStep := #eStep_Restart;
	            
	        #eStep_Restart:
	            #ReconfigIOSystem.REQ := TRUE;
	            #ReconfigIOSystem.MODE := 3;
	            IF #ReconfigIOSystem.DONE THEN
	                #iNextStep := #eStep_Done;
	            END_IF;
	                
	        ELSE
	            #ReconfigIOSystem.REQ := FALSE;
	            #ReconfigIOSystem.MODE := 0;
	            
	    END_CASE;
	    *)
	    
	    
	    (*
	    #ReconfigIOSystem(REQ := #ReconfigIOSystem.REQ,
	                      MODE := #ReconfigIOSystem.MODE,
	                      LADDR := "Local~PROFINET_interface_1",
	                      CTRLREC := #arrVfdDeviceConfig,
	                      STATUS => #ReconfigIOSystem.STATUS,
	                      BUSY => #ReconfigIOSystem.BUSY,
	                      DONE => #ReconfigIOSystem.DONE,
	                      ERROR => #ReconfigIOSystem.ERROR);
	    
	    // catch and log error
	    IF #ReconfigIOSystem.ERROR THEN
	        #Status.ErrorMsg := CONCAT(IN1 := #Status.ErrorMsg, IN2 := ' ReconfigIO Error Code: ');
	        #retVal := HTA(IN := #ReconfigIOSystem.STATUS, N := 4, OUT => #strErrorCode);
	        #Status.ErrorMsg := CONCAT(IN1 := #Status.ErrorMsg, IN2 := #strErrorCode);
	        
	        #Status.ErrorMsg := CONCAT(IN1 := #Status.ErrorMsg, IN2 := ' On device: ');
	        #retVal := HTA(IN := #ReconfigIOSystem.ERR_INFO, N := 2, OUT => #strErrorCode);
	        #Status.ErrorMsg := CONCAT(IN1 := #Status.ErrorMsg, IN2 := #strErrorCode);
	        
	        #iNextStep := #eStep_Error;
	    END_IF;
	    
	END_REGION
	    *)
	    
	
	
	
	
	REGION Set status outputs
	    #Status.bDone := #iStep = #eStep_Done;
	    #Status.bBusy := #iStep <> #eStep_Done AND #iStep <> #eStep_Error;
	    #Status.bError := #iStep = #eStep_Error;
	    
	END_REGION
	
	// set step for next scan
	#iStep := #iNextStep;
END_FUNCTION_BLOCK

